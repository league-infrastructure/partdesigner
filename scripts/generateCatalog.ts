import { promises as fs } from 'fs';
import path from 'path';
import { parse } from 'node-html-parser';

interface CatalogEntry {
  id: number;
  name: string;
  partString: string;
  sourceFile: string;
}

const DATA_DIR = path.resolve(__dirname, '../data');
const OUTPUT_FILE = path.resolve(__dirname, '../src/editor/catalogData.ts');
const BOOKMARK_FILE_PATTERN = /bookmark/i;

async function findBookmarkFiles(): Promise<string[]> {
  const entries = await fs.readdir(DATA_DIR, { withFileTypes: true });
  return entries
    .filter((entry) => entry.isFile() && BOOKMARK_FILE_PATTERN.test(entry.name))
    .map((entry) => path.join(DATA_DIR, entry.name));
}

function extractCatalogEntries(html: string, sourceFile: string): CatalogEntry[] {
  const root = parse(html);
  const legoFolder = root.querySelectorAll('h3').find((node) => node.text.trim().toLowerCase() === 'lego parts');
  if (!legoFolder) {
    return [];
  }

  const container =
    legoFolder.parentNode?.querySelector('dl') ||
    legoFolder.nextElementSibling?.querySelector('dl') ||
    legoFolder.parentNode;

  if (!container) {
    return [];
  }

  const links = container.querySelectorAll('a');
  const entries: CatalogEntry[] = [];
  for (const link of links) {
    const href = link.getAttribute('href');
    if (!href) continue;
    let url: URL;
    try {
      url = new URL(href);
    } catch (error) {
      continue; // skip malformed links
    }
    const partString = url.searchParams.get('part');
    if (!partString) continue;
    const nameParam = url.searchParams.get('name');
    const name = nameParam ? nameParam : link.text.trim();
    entries.push({
      id: entries.length + 1,
      name,
      partString,
      sourceFile: path.basename(sourceFile),
    });
  }
  return entries;
}

function renderCatalogFile(entries: CatalogEntry[]): string {
  const rows = entries
    .map(
      (entry) =>
        `  { id: ${entry.id}, name: ${JSON.stringify(entry.name)}, partString: ${JSON.stringify(entry.partString)} }`
    )
    .join(',\n');

  return `// AUTO-GENERATED by npm run generate-catalog. Do not edit by hand.\n` +
    `// Source files: data/*.html\n` +
    `interface CatalogEntry { id: number; name: string; partString: string; }\n` +
    `const GENERATED_CATALOG: CatalogEntry[] = [\n${rows}\n];\n`;
}

async function run() {
  const files = await findBookmarkFiles();
  if (files.length === 0) {
    throw new Error(`No bookmark files found in ${DATA_DIR}`);
  }

  const seen = new Set<string>();
  const collected: CatalogEntry[] = [];

  for (const filePath of files) {
    const html = await fs.readFile(filePath, 'utf8');
    const entries = extractCatalogEntries(html, filePath);
    for (const entry of entries) {
      if (seen.has(entry.partString)) continue;
      seen.add(entry.partString);
      collected.push({ ...entry, id: collected.length + 1 });
    }
  }

  if (collected.length === 0) {
    throw new Error(`Found bookmark files but no Lego Parts entries.`);
  }

  const output = renderCatalogFile(collected);
  await fs.writeFile(OUTPUT_FILE, output, 'utf8');
  console.log(`Wrote ${collected.length} catalog entries to ${OUTPUT_FILE}`);
}

run().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
